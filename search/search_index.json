{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Discover all the incredible capabilities of our platform so that you can protect your Microsoft 365 environment and leverage third-party apps securely. GraphShield is: - An intelligent proxy that provides observability, auditing, and firewall capabilities to your Microsoft 365 custom and third-party apps that rely on the Microsoft Graph API. - A comprehensive dashboard that allows you to define security and compliance policies, discover anomalies, receive alerts and understand how apps are using your Microsoft 365 resources. You're a Microsoft 365 Security Professional? GraphShield protects your Microsoft 365 Environment through powerful security and compliance policies: - Proactively deny access to compromised apps (IP-based threat detection) - Fine-grained OAuth permissions (such as a restricted access to VIPs-related data) - Content-based Data Loss Prevention (DLP), PII redaction and randomization - Intelligent monitoring dashboards and automated audit trails Get Started as a Microsoft 365 Security Professional You're a Microsoft Graph Apps Developer? GraphShield brings advanced enterprise-grade capabilities to your apps without requiring any code change: - Use the \"Protected by GraphShield\" logo. - Bring \"Enterprise grade\" features for your customers without any code change. - Offer a hybrid architecture option to enterprise customers concerned about a 100% SAAS-based model. Get Started as a Microsoft Graph SAAS Apps Developer","title":"Overview"},{"location":"#overview","text":"Discover all the incredible capabilities of our platform so that you can protect your Microsoft 365 environment and leverage third-party apps securely. GraphShield is: - An intelligent proxy that provides observability, auditing, and firewall capabilities to your Microsoft 365 custom and third-party apps that rely on the Microsoft Graph API. - A comprehensive dashboard that allows you to define security and compliance policies, discover anomalies, receive alerts and understand how apps are using your Microsoft 365 resources.","title":"Overview"},{"location":"#youre-a-microsoft-365-security-professional","text":"GraphShield protects your Microsoft 365 Environment through powerful security and compliance policies: - Proactively deny access to compromised apps (IP-based threat detection) - Fine-grained OAuth permissions (such as a restricted access to VIPs-related data) - Content-based Data Loss Prevention (DLP), PII redaction and randomization - Intelligent monitoring dashboards and automated audit trails Get Started as a Microsoft 365 Security Professional","title":"You're a Microsoft 365 Security Professional?"},{"location":"#youre-a-microsoft-graph-apps-developer","text":"GraphShield brings advanced enterprise-grade capabilities to your apps without requiring any code change: - Use the \"Protected by GraphShield\" logo. - Bring \"Enterprise grade\" features for your customers without any code change. - Offer a hybrid architecture option to enterprise customers concerned about a 100% SAAS-based model. Get Started as a Microsoft Graph SAAS Apps Developer","title":"You're a Microsoft Graph Apps Developer?"},{"location":"how-does-it-work/","text":"How does it work? ABSTRACT From a logical standpoint, GraphShield acts as a firewall that stands between your custom and third-party SAAS apps and the Microsoft Graph. graph BT customapp[Custom App] thirdpartyapp[Third-party App] gs[GraphShield] msg[Microsoft Graph] customapp --> gs thirdpartyapp --> gs gs --> msg How GraphShield Handles Transactions Once a request is received to microsoftgraph.graphshield.app from a client app, it passes through a serie of middlewares, that could control access to the Microsoft Graph resources (pre-processing \"inbound\" policies), and alter the response from the Microsoft Graph (post-processing \"outbound\" policies): sequenceDiagram autonumber participant client as Client participant gsf as GraphShield Firewall participant gsp as GraphShield Policies participant msg as Microsoft Graph client ->> +gsf: Request gsf ->> +gsp: Pre-processing gsp -->> +msg: If inbound policies checks OK msg ->> gsp: Response gsp ->> gsf: Response gsf ->> +gsp: Post-processing gsp -->> +gsf: If outbound policies OK gsf ->> +client: Response GraphShield understands the Microsoft Graph Contrary to a regular firewall or even an application reverse proxy, GraphShield \"understands\" Microsoft Graph requests and responses. GraphShield implements a set of intelligent policies and rules that process requests and responses so that it has zero impact on third-party apps. For instance, here is the result of a user profile ( /me ) query protected by our PII masking policy. { \"@odata.context\" : \"https://graph.microsoft.com/v1.0/$metadata#users/$entity\" , \"displayName\" : \"###-REDACTED-PERSON-###\" , \"userPrincipalName\" : \"###-REDACTED-EMAIL-###\" ... } Similarly, here is the result of a teams ( /me/joinedTeams ) query protected by our classification masking policy. Note that some teams from the value property are dynamically hidden based on their classification level, and that the @odata.count property is updated accordingly. { \"@odata.context\" : \"https://graph.microsoft.com/v1.0/$metadata#teams\" , \"@odata.count\" : 23 , \"value\" : [ { \"id\" : \"team-id\" , \"displayName\" : \"team-display-name\" , ... } ... Finally, here is the result of a teams ( /teams/{id} ) query protected by our classification masking policy. Note that the response HTTP status code will be 403 , and that the response object respects the Microsoft Graph error JSON format. Learn more about GraphShield errors . { \"error\" : { \"code\" : \"classifiedGroup\" , \"message\" : \"Middleware io.graphshield.rules.hide-classified-groups.parse-response-body: This group is classified and cannot be retreived.\" , \"innerError\" : { \"requestId\" : \"request-id\" , \"date\" : \"date-time\" } } }","title":"How does it work?"},{"location":"how-does-it-work/#how-does-it-work","text":"ABSTRACT From a logical standpoint, GraphShield acts as a firewall that stands between your custom and third-party SAAS apps and the Microsoft Graph. graph BT customapp[Custom App] thirdpartyapp[Third-party App] gs[GraphShield] msg[Microsoft Graph] customapp --> gs thirdpartyapp --> gs gs --> msg","title":"How does it work?"},{"location":"how-does-it-work/#how-graphshield-handles-transactions","text":"Once a request is received to microsoftgraph.graphshield.app from a client app, it passes through a serie of middlewares, that could control access to the Microsoft Graph resources (pre-processing \"inbound\" policies), and alter the response from the Microsoft Graph (post-processing \"outbound\" policies): sequenceDiagram autonumber participant client as Client participant gsf as GraphShield Firewall participant gsp as GraphShield Policies participant msg as Microsoft Graph client ->> +gsf: Request gsf ->> +gsp: Pre-processing gsp -->> +msg: If inbound policies checks OK msg ->> gsp: Response gsp ->> gsf: Response gsf ->> +gsp: Post-processing gsp -->> +gsf: If outbound policies OK gsf ->> +client: Response","title":"How GraphShield Handles Transactions"},{"location":"how-does-it-work/#graphshield-understands-the-microsoft-graph","text":"Contrary to a regular firewall or even an application reverse proxy, GraphShield \"understands\" Microsoft Graph requests and responses. GraphShield implements a set of intelligent policies and rules that process requests and responses so that it has zero impact on third-party apps. For instance, here is the result of a user profile ( /me ) query protected by our PII masking policy. { \"@odata.context\" : \"https://graph.microsoft.com/v1.0/$metadata#users/$entity\" , \"displayName\" : \"###-REDACTED-PERSON-###\" , \"userPrincipalName\" : \"###-REDACTED-EMAIL-###\" ... } Similarly, here is the result of a teams ( /me/joinedTeams ) query protected by our classification masking policy. Note that some teams from the value property are dynamically hidden based on their classification level, and that the @odata.count property is updated accordingly. { \"@odata.context\" : \"https://graph.microsoft.com/v1.0/$metadata#teams\" , \"@odata.count\" : 23 , \"value\" : [ { \"id\" : \"team-id\" , \"displayName\" : \"team-display-name\" , ... } ... Finally, here is the result of a teams ( /teams/{id} ) query protected by our classification masking policy. Note that the response HTTP status code will be 403 , and that the response object respects the Microsoft Graph error JSON format. Learn more about GraphShield errors . { \"error\" : { \"code\" : \"classifiedGroup\" , \"message\" : \"Middleware io.graphshield.rules.hide-classified-groups.parse-response-body: This group is classified and cannot be retreived.\" , \"innerError\" : { \"requestId\" : \"request-id\" , \"date\" : \"date-time\" } } }","title":"GraphShield understands the Microsoft Graph"},{"location":"integration/","text":"Integrate your apps with GraphShield GraphShield was designed so that you can integrate your app with almost zero change to your code. No external agent, nothing to install, nada, zero! ABSTRACT Under the hood, you access GraphShield simply by calling microsoftgraph.graphshield.app instead of the regular graph.microsoft.com URL. It means that you can integrate your app with GraphShield easily, in a snap, in a very transparent way. 'https://graph.microsoft.com/v1.0/me' // Instead of this 'https://microsoftgraph.graphshield.app/v1.0/me' // Use this Yes, it's that simple! To understand more deeply what a full transaction looks like and how a request is processed, see how does it works . How to integrate your app with GraphShield? If you're using a REST client Using any REST-compatible client, just include the GraphShield base URL in your requests: const GRAPHSHIELD_URL = 'https://microsoftgraph.graphshield.app' request . get ( GRAPHSHIELD_URL + '/v1.0/me' ) . set ( 'Authorization' , 'Bearer ' + accessToken ) . end (( err , res ) => { Tip This technique applies to any REST-compatible client, such as fetch , node-fetch , axios ... in any language. If you're using the Microsoft Graph Client If you're using the Microsoft Graph Client SDK, just include the baseUrl option to your Microsoft Graph client constructor, as highlighted: const options = { authProvider , baseUrl : 'https://microsoftgraph.graphshield.app/' } const client = Client . init ( options ) let res = await client . api ( '/me' ) . get () Tip This technique should work with the Microsoft Graph Client in any language, Javascript , C# , Java ... Warning Using a specific Microsoft Graph environment? The Microsoft Graph API is available from different environments, and you have to use a different URL for each of them, for instance: - Microsoft Graph for US Government L4: https://graph.microsoft.us - Microsoft Graph for US Government L5 (DOD): https://dod-graph.microsoft.us - Microsoft Graph Germany: https://graph.microsoft.de See Microsoft Graph root endpoints for reference. If you're in the situation where you need to access one of these specific Microsoft Graph environments, just contact us . If you're using Power Automate or PowerApps If you're using Power Automate or PowerApps to access the Microsoft Graph, we've got you covered too! Just include the GraphShield base URL in the URI field of your HTTP action. Next Steps Well... you're good to go! Once you've updated your base URL, GraphShield take care of everything so that you don't have to. But if you want to understand how GraphShield handles \"edge cases\", please refer to the following articles: - Authentication - Async Operations - Subscriptions - Errors Management - Throttling","title":"Integrate your apps with GraphShield"},{"location":"integration/#integrate-your-apps-with-graphshield","text":"GraphShield was designed so that you can integrate your app with almost zero change to your code. No external agent, nothing to install, nada, zero! ABSTRACT Under the hood, you access GraphShield simply by calling microsoftgraph.graphshield.app instead of the regular graph.microsoft.com URL. It means that you can integrate your app with GraphShield easily, in a snap, in a very transparent way. 'https://graph.microsoft.com/v1.0/me' // Instead of this 'https://microsoftgraph.graphshield.app/v1.0/me' // Use this Yes, it's that simple! To understand more deeply what a full transaction looks like and how a request is processed, see how does it works .","title":"Integrate your apps with GraphShield"},{"location":"integration/#how-to-integrate-your-app-with-graphshield","text":"","title":"How to integrate your app with GraphShield?"},{"location":"integration/#if-youre-using-a-rest-client","text":"Using any REST-compatible client, just include the GraphShield base URL in your requests: const GRAPHSHIELD_URL = 'https://microsoftgraph.graphshield.app' request . get ( GRAPHSHIELD_URL + '/v1.0/me' ) . set ( 'Authorization' , 'Bearer ' + accessToken ) . end (( err , res ) => { Tip This technique applies to any REST-compatible client, such as fetch , node-fetch , axios ... in any language.","title":"If you're using a REST client"},{"location":"integration/#if-youre-using-the-microsoft-graph-client","text":"If you're using the Microsoft Graph Client SDK, just include the baseUrl option to your Microsoft Graph client constructor, as highlighted: const options = { authProvider , baseUrl : 'https://microsoftgraph.graphshield.app/' } const client = Client . init ( options ) let res = await client . api ( '/me' ) . get () Tip This technique should work with the Microsoft Graph Client in any language, Javascript , C# , Java ... Warning Using a specific Microsoft Graph environment? The Microsoft Graph API is available from different environments, and you have to use a different URL for each of them, for instance: - Microsoft Graph for US Government L4: https://graph.microsoft.us - Microsoft Graph for US Government L5 (DOD): https://dod-graph.microsoft.us - Microsoft Graph Germany: https://graph.microsoft.de See Microsoft Graph root endpoints for reference. If you're in the situation where you need to access one of these specific Microsoft Graph environments, just contact us .","title":"If you're using the Microsoft Graph Client"},{"location":"integration/#if-youre-using-power-automate-or-powerapps","text":"If you're using Power Automate or PowerApps to access the Microsoft Graph, we've got you covered too! Just include the GraphShield base URL in the URI field of your HTTP action.","title":"If you're using Power Automate or PowerApps"},{"location":"integration/#next-steps","text":"Well... you're good to go! Once you've updated your base URL, GraphShield take care of everything so that you don't have to. But if you want to understand how GraphShield handles \"edge cases\", please refer to the following articles: - Authentication - Async Operations - Subscriptions - Errors Management - Throttling","title":"Next Steps"},{"location":"integration/async-operations/","text":"Async Operations Some Microsoft Graph operations require indeterminate time to complete. Instead of waiting until the action is complete before returning a response, Microsoft Graph may use a long running actions pattern. This pattern provides your app a way to poll for status updates on a long running action, without any request waiting for the action to complete. Examples When a Microsoft Graph operation transcends the lifetime of a single API request, it returns a 202 Accepted response code with a Location header, that you can periodically check by making a GET request to this location. An example is the Clone a team operation that uses a teamsAsyncOperation resource type : HTTP / 1.1 202 Accepted Location : /teams({id})/operations({opId}) Another example is the Copy a DriveItem operation that uses an AsyncJobStatus resource : HTTP / 1.1 202 Accepted Location : https://contoso.sharepoint.com/_api/v2.0/monitor/{id} How GraphShield makes it transparent? To make sure that your app doesn't try by accident to bypass GraphShield by automatically following this kind of dynamically generated location URL, GraphShield dynamically rewrites the Location HTTP header to replace URLs such as https://api.onedrive.com/monitor/{id} by https://microsoftgraph.graphshield.app?location=https://api.onedrive.com/monitor/{id} , making this operation entirely transparent for your app.","title":"Async Operations"},{"location":"integration/async-operations/#async-operations","text":"Some Microsoft Graph operations require indeterminate time to complete. Instead of waiting until the action is complete before returning a response, Microsoft Graph may use a long running actions pattern. This pattern provides your app a way to poll for status updates on a long running action, without any request waiting for the action to complete.","title":"Async Operations"},{"location":"integration/async-operations/#examples","text":"When a Microsoft Graph operation transcends the lifetime of a single API request, it returns a 202 Accepted response code with a Location header, that you can periodically check by making a GET request to this location. An example is the Clone a team operation that uses a teamsAsyncOperation resource type : HTTP / 1.1 202 Accepted Location : /teams({id})/operations({opId}) Another example is the Copy a DriveItem operation that uses an AsyncJobStatus resource : HTTP / 1.1 202 Accepted Location : https://contoso.sharepoint.com/_api/v2.0/monitor/{id}","title":"Examples"},{"location":"integration/async-operations/#how-graphshield-makes-it-transparent","text":"To make sure that your app doesn't try by accident to bypass GraphShield by automatically following this kind of dynamically generated location URL, GraphShield dynamically rewrites the Location HTTP header to replace URLs such as https://api.onedrive.com/monitor/{id} by https://microsoftgraph.graphshield.app?location=https://api.onedrive.com/monitor/{id} , making this operation entirely transparent for your app.","title":"How GraphShield makes it transparent?"},{"location":"integration/authentication/","text":"Authentication GraphShield was designed so that it interfere as less as possible with your authentication process. Abstract GraphShield supports two modes of authentication, Standard and Hardened . Tip The Standard mode is perfect to use GraphShield without any additional constraints. The Hardened mode may be required when you're dealing with a strictly controlled Microsoft 365 environment. Standard mode In standard mode, to call the Microsoft Graph API through GraphShield, your application just need to acquire a regular OAuth 2.0 Access token from the Microsoft Identity Platform, and present it in either of the following: - The HTTP Authorization request header, as a Bearer token - The graph client constructor, when using a Microsoft Graph client library sequenceDiagram autonumber participant client as Client participant gs as GraphShield participant msg as Microsoft Graph participant mip as Microsoft identity platform client ->> +gs: Request with access token gs -->> +msg: If inbound policies checks OK msg ->> +mip: Authentication mip -->> +msg: If authentication OK msg -->> +gs: If outbound policies checks OK gs ->> +client: Response It means that in standard mode, GraphShield is completely transparent regarding your authentication process , as you're dealing directly with the Microsoft Identity Platform. Therefore you can refer to the standard Microsoft Graph auth overview for reference to understand how to acquire an access token. Hardened mode To cope with advanced security and compliance requirements in certain Microsoft 365 environments, GraphShield offers an additional layer of security for Microsoft 365 organizations through the concept of \"Virtual Tokens\". Virtual Tokens prevents apps from directly accessing real application id and secrets, bringing an additional layer of security by completely preventing an app to be able to bypass GraphShield and to make direct requests to the Microsoft Graph. With GraphShield, they are only two differences with the regular flow: - You're calling https://microsoftidentity.graphshield.app instead of the regular https://login.microsoftonline.com URLs. - You're passing a virtual app id and a virtual app secret instead of the real one. These app id and secret are verified then dynamically substituted by the real one during the proxying process. We're currently supporting virtual tokens in these two main scenarios, that should cover 99% of the situations: - Access on behalf of a user: Used by single page apps , web apps , and natively installed apps - Access without a user: Used for server-to-server interactions that must run in the background !!! warning Other OAuth 2.0 and OpenID protocols If you need to use other protocols, such as OAuth 2.0 on-behalf-of flow or OAuth 2.0 device code flow , just contact us . Access on behalf of a user The OAuth 2.0 authorization code flow is described in section 4.1 of the OAuth 2.0 specification . It's used to perform authentication and authorization in the majority of app types, including single page apps, web apps, and natively installed apps. The flow enables apps to securely acquire access_tokens that can be used to access resources secured by the Microsoft identity platform, as well as refresh tokens to get additional access_tokens, and ID tokens for the signed in user. By using GraphShield, the resulting process is completely transparent and does not impact your app: sequenceDiagram autonumber participant client as Client participant gs as GraphShield participant mip as Microsoft Identity Platform client ->> +gs: GET with virtual app id gs ->> +mip: GET /Authorize mip -->> +gs: If authentication OK gs ->> +client: Authentication code client ->> +gs: POST with virtual app id/secret + authentication code gs ->> +mip: POST /Token mip -->> +gs: If authentication code OK gs ->> +client: Access and refresh tokens !!! warning Using a national environment? (US, DE, CN...) See Using a specific Microsoft Identity Platform environment if required. Access without a user You can use the OAuth 2.0 client credentials grant specified in RFC 6749 , sometimes called \"two-legged OAuth\", to access web-hosted resources by using the identity of an application. This type of grant is commonly used for server-to-server interactions that must run in the background, without immediate interaction with a user. These types of applications are often referred to as daemons or service accounts. By using GraphShield, the resulting process is completely transparent and does not impact your app: sequenceDiagram autonumber participant client as Client participant gs as GraphShield participant mip as Microsoft Identity Platform client ->> +gs: GET with virtual app id gs ->> +mip: GET /adminconsent mip -->> +gs: If authentication and grant OK gs ->> +client: Admin consent result client ->> +gs: POST with virtual app id/secret gs ->> +mip: POST /Token mip -->> +gs: If app id/secret combination OK gs ->> +client: Access token Warning Using a national environment? (US, DE, CN...) See Using a specific Microsoft Identity Platform environment if required. Using a Microsoft Identity Platform national environment The Microsoft Identity Platform is available from different environments, and you have to use a different URL for each of them, for instance: - Azure AD for US Government: https://login.microsoftonline.us - Azure AD Germany: https://login.microsoftonline.de - Azure AD China operated by 21Vianet: https://login.chinacloudapi.cn See Token service root endpoints for reference. If you're in the situation where you need to access one of these specific Microsoft Identity Platform environments, just contact us .","title":"Authentication"},{"location":"integration/authentication/#authentication","text":"GraphShield was designed so that it interfere as less as possible with your authentication process.","title":"Authentication"},{"location":"integration/authentication/#abstract","text":"GraphShield supports two modes of authentication, Standard and Hardened . Tip The Standard mode is perfect to use GraphShield without any additional constraints. The Hardened mode may be required when you're dealing with a strictly controlled Microsoft 365 environment.","title":"Abstract"},{"location":"integration/authentication/#standard-mode","text":"In standard mode, to call the Microsoft Graph API through GraphShield, your application just need to acquire a regular OAuth 2.0 Access token from the Microsoft Identity Platform, and present it in either of the following: - The HTTP Authorization request header, as a Bearer token - The graph client constructor, when using a Microsoft Graph client library sequenceDiagram autonumber participant client as Client participant gs as GraphShield participant msg as Microsoft Graph participant mip as Microsoft identity platform client ->> +gs: Request with access token gs -->> +msg: If inbound policies checks OK msg ->> +mip: Authentication mip -->> +msg: If authentication OK msg -->> +gs: If outbound policies checks OK gs ->> +client: Response It means that in standard mode, GraphShield is completely transparent regarding your authentication process , as you're dealing directly with the Microsoft Identity Platform. Therefore you can refer to the standard Microsoft Graph auth overview for reference to understand how to acquire an access token.","title":"Standard mode"},{"location":"integration/authentication/#hardened-mode","text":"To cope with advanced security and compliance requirements in certain Microsoft 365 environments, GraphShield offers an additional layer of security for Microsoft 365 organizations through the concept of \"Virtual Tokens\". Virtual Tokens prevents apps from directly accessing real application id and secrets, bringing an additional layer of security by completely preventing an app to be able to bypass GraphShield and to make direct requests to the Microsoft Graph. With GraphShield, they are only two differences with the regular flow: - You're calling https://microsoftidentity.graphshield.app instead of the regular https://login.microsoftonline.com URLs. - You're passing a virtual app id and a virtual app secret instead of the real one. These app id and secret are verified then dynamically substituted by the real one during the proxying process. We're currently supporting virtual tokens in these two main scenarios, that should cover 99% of the situations: - Access on behalf of a user: Used by single page apps , web apps , and natively installed apps - Access without a user: Used for server-to-server interactions that must run in the background !!! warning Other OAuth 2.0 and OpenID protocols If you need to use other protocols, such as OAuth 2.0 on-behalf-of flow or OAuth 2.0 device code flow , just contact us .","title":"Hardened mode"},{"location":"integration/authentication/#access-on-behalf-of-a-user","text":"The OAuth 2.0 authorization code flow is described in section 4.1 of the OAuth 2.0 specification . It's used to perform authentication and authorization in the majority of app types, including single page apps, web apps, and natively installed apps. The flow enables apps to securely acquire access_tokens that can be used to access resources secured by the Microsoft identity platform, as well as refresh tokens to get additional access_tokens, and ID tokens for the signed in user. By using GraphShield, the resulting process is completely transparent and does not impact your app: sequenceDiagram autonumber participant client as Client participant gs as GraphShield participant mip as Microsoft Identity Platform client ->> +gs: GET with virtual app id gs ->> +mip: GET /Authorize mip -->> +gs: If authentication OK gs ->> +client: Authentication code client ->> +gs: POST with virtual app id/secret + authentication code gs ->> +mip: POST /Token mip -->> +gs: If authentication code OK gs ->> +client: Access and refresh tokens !!! warning Using a national environment? (US, DE, CN...) See Using a specific Microsoft Identity Platform environment if required.","title":"Access on behalf of a user"},{"location":"integration/authentication/#access-without-a-user","text":"You can use the OAuth 2.0 client credentials grant specified in RFC 6749 , sometimes called \"two-legged OAuth\", to access web-hosted resources by using the identity of an application. This type of grant is commonly used for server-to-server interactions that must run in the background, without immediate interaction with a user. These types of applications are often referred to as daemons or service accounts. By using GraphShield, the resulting process is completely transparent and does not impact your app: sequenceDiagram autonumber participant client as Client participant gs as GraphShield participant mip as Microsoft Identity Platform client ->> +gs: GET with virtual app id gs ->> +mip: GET /adminconsent mip -->> +gs: If authentication and grant OK gs ->> +client: Admin consent result client ->> +gs: POST with virtual app id/secret gs ->> +mip: POST /Token mip -->> +gs: If app id/secret combination OK gs ->> +client: Access token Warning Using a national environment? (US, DE, CN...) See Using a specific Microsoft Identity Platform environment if required.","title":"Access without a user"},{"location":"integration/authentication/#using-a-microsoft-identity-platform-national-environment","text":"The Microsoft Identity Platform is available from different environments, and you have to use a different URL for each of them, for instance: - Azure AD for US Government: https://login.microsoftonline.us - Azure AD Germany: https://login.microsoftonline.de - Azure AD China operated by 21Vianet: https://login.chinacloudapi.cn See Token service root endpoints for reference. If you're in the situation where you need to access one of these specific Microsoft Identity Platform environments, just contact us .","title":"Using a Microsoft Identity Platform national environment"},{"location":"integration/errors/","text":"Error Responses Just like the Microsoft Graph, errors in GraphShield are returned using standard HTTP status codes, as well as a JSON error response object. HTTP Status Codes The following table lists and describes the HTTP status codes that can be returned: Status code Status message Description 400 Bad Request Cannot process the request because it is malformed or incorrect. 401 Unauthorized Required authentication information is either missing or not valid for the resource. 403 Forbidden Access is denied to the requested resource. The user or application might not have enough permission. 429 Too Many Requests Client application has been throttled and should not attempt to repeat the request until an amount of time has elapsed. 500 Internal Server Error There was an internal server error while processing the request. 509 Bandwidth Limit Exceeded Your app has been throttled for exceeding the maximum bandwidth cap. Your app can retry the request again after more time has elapsed. The error response is a single JSON object that contains a single property named error . This object includes all the details of the error. You can use the information returned here instead of or in addition to the HTTP status code. The following is an example of a full JSON error body. { \"error\" : { \"code\" : \"unauthorized\" , \"message\" : \"Required authentication information is either missing...\" , \"innerError\" : { \"requestId\" : \"4c15cc1b-2f06-4a5a-86c0-dfe118f74cfe\" , // UUID v4 \"date\" : \"2021-02-27T15:36:23.972Z\" // ISO format } } } How GraphShield makes it transparent? GraphShield generates its errors (internal errors, policy violations...) using exactly the same schema as the Microsoft Graph, making error handling completely transparent for your app. See Microsoft Graph error responses and resource types for reference.","title":"Error Responses"},{"location":"integration/errors/#error-responses","text":"Just like the Microsoft Graph, errors in GraphShield are returned using standard HTTP status codes, as well as a JSON error response object.","title":"Error Responses"},{"location":"integration/errors/#http-status-codes","text":"The following table lists and describes the HTTP status codes that can be returned: Status code Status message Description 400 Bad Request Cannot process the request because it is malformed or incorrect. 401 Unauthorized Required authentication information is either missing or not valid for the resource. 403 Forbidden Access is denied to the requested resource. The user or application might not have enough permission. 429 Too Many Requests Client application has been throttled and should not attempt to repeat the request until an amount of time has elapsed. 500 Internal Server Error There was an internal server error while processing the request. 509 Bandwidth Limit Exceeded Your app has been throttled for exceeding the maximum bandwidth cap. Your app can retry the request again after more time has elapsed. The error response is a single JSON object that contains a single property named error . This object includes all the details of the error. You can use the information returned here instead of or in addition to the HTTP status code. The following is an example of a full JSON error body. { \"error\" : { \"code\" : \"unauthorized\" , \"message\" : \"Required authentication information is either missing...\" , \"innerError\" : { \"requestId\" : \"4c15cc1b-2f06-4a5a-86c0-dfe118f74cfe\" , // UUID v4 \"date\" : \"2021-02-27T15:36:23.972Z\" // ISO format } } }","title":"HTTP Status Codes"},{"location":"integration/errors/#how-graphshield-makes-it-transparent","text":"GraphShield generates its errors (internal errors, policy violations...) using exactly the same schema as the Microsoft Graph, making error handling completely transparent for your app. See Microsoft Graph error responses and resource types for reference.","title":"How GraphShield makes it transparent?"},{"location":"integration/subscriptions/","text":"Subscriptions Subscriptions enables you to receive change notifications when a specific type of changes occur to the specified resource in Microsoft Graph. Example A typical example of a subscription is to listen for the arrival of new messanges in an inbox. To create this kind of subscription, you will typically post: POST https://microsoftgraph.graphshield.app/v1.0/subscriptions Content-type: application/json With the following body: { \"changeType\" : \"created\" , \"notificationUrl\" : \"https://webhook.azurewebsites.net/api/send/myNotifyClient\" , \"resource\" : \"me/mailFolders('Inbox')/messages\" , } Then when a new message is received, you'll receive a POST request to your notificationUrl with this kind of payload: { \"value\" : [ { \"id\" : \"lsgTZMr9KwAAA\" , \"subscriptionId\" : \"{subscription_guid}\" , \"subscriptionExpirationDateTime\" : \"2016-03-19T22:11:09.952Z\" , \"clientState\" : \"secretClientValue\" , \"changeType\" : \"created\" , \"resource\" : \"users/{user_guid}@{tenant_guid}/messages/{long_id_string}\" , \"tenantId\" : \"{tenant_id}\" , \"resourceData\" : { \"@odata.type\" : \"#Microsoft.Graph.Message\" , \"@odata.id\" : \"Users/{user_guid}@{tenant_guid}/Messages/{long_id_string}\" , \"@odata.etag\" : \"W/\\\"CQAAABYAAADkrWGo7bouTKlsgTZMr9KwAAAUWRHf\\\"\" , \"id\" : \"{long_id_string}\" } } ] } How GraphShield makes it transparent? To make sure that your app doesn't bypass GraphShield by accident by receiving direct change notifications from the Microsoft Graph, GraphShield dynamically replaces your original notificationUrl by a GraphShield-specific one. Then, when the Microsoft Graph emits a webhook request (could be the initial endpoint validation or a change notification ), GraphShield dynamically relays the request to your original locationUrl .","title":"Subscriptions"},{"location":"integration/subscriptions/#subscriptions","text":"Subscriptions enables you to receive change notifications when a specific type of changes occur to the specified resource in Microsoft Graph.","title":"Subscriptions"},{"location":"integration/subscriptions/#example","text":"A typical example of a subscription is to listen for the arrival of new messanges in an inbox. To create this kind of subscription, you will typically post: POST https://microsoftgraph.graphshield.app/v1.0/subscriptions Content-type: application/json With the following body: { \"changeType\" : \"created\" , \"notificationUrl\" : \"https://webhook.azurewebsites.net/api/send/myNotifyClient\" , \"resource\" : \"me/mailFolders('Inbox')/messages\" , } Then when a new message is received, you'll receive a POST request to your notificationUrl with this kind of payload: { \"value\" : [ { \"id\" : \"lsgTZMr9KwAAA\" , \"subscriptionId\" : \"{subscription_guid}\" , \"subscriptionExpirationDateTime\" : \"2016-03-19T22:11:09.952Z\" , \"clientState\" : \"secretClientValue\" , \"changeType\" : \"created\" , \"resource\" : \"users/{user_guid}@{tenant_guid}/messages/{long_id_string}\" , \"tenantId\" : \"{tenant_id}\" , \"resourceData\" : { \"@odata.type\" : \"#Microsoft.Graph.Message\" , \"@odata.id\" : \"Users/{user_guid}@{tenant_guid}/Messages/{long_id_string}\" , \"@odata.etag\" : \"W/\\\"CQAAABYAAADkrWGo7bouTKlsgTZMr9KwAAAUWRHf\\\"\" , \"id\" : \"{long_id_string}\" } } ] }","title":"Example"},{"location":"integration/subscriptions/#how-graphshield-makes-it-transparent","text":"To make sure that your app doesn't bypass GraphShield by accident by receiving direct change notifications from the Microsoft Graph, GraphShield dynamically replaces your original notificationUrl by a GraphShield-specific one. Then, when the Microsoft Graph emits a webhook request (could be the initial endpoint validation or a change notification ), GraphShield dynamically relays the request to your original locationUrl .","title":"How GraphShield makes it transparent?"},{"location":"integration/throttling/","text":"Throttling Guidance Throttling limits the number of concurrent calls to a service to prevent overuse of resources. Graphshield is designed to handle a high volume of requests. If an overwhelming number of requests occurs, throttling helps maintain optimal performance and reliability of the service. Common Throttling Scenarios The most common causes of throttling of clients include: - A large number of requests across all applications in a our environments. - A large number of requests from a particular application across all environments. What Happens when Throttling Occurs? When a throttling threshold is exceeded, GraphShield limits any further requests from that client for a period of time. When throttling occurs, GraphShield returns HTTP status code 429 (Too many requests), and the requests fail. A suggested wait time is returned in the response header of the failed request. GraphShield is conforming to the IETF ratelimit standardization proposal . Best Practices to Avoid Throttling Programming patterns like continuously polling a resource to check for updates and regularly scanning resource collections to check for new or deleted resources are more likely to lead to applications being throttled and degrade overall performances. Before any throttling, GraphShield provides two useful headers included in every responses so that you can monitor your own activity level: - X-RateLimit-Limit : The limit of requests in a perdiod of time (aka \"window\") - X-RateLimit-Remaining : The current number of requests that could be made during the current window. How to Handle Throttling The following are best practices for handling throttling: - Reduce the number of operations per request. - Reduce the frequency of calls. - Avoid immediate retries, because all requests accrue against your usage limits. When you implement error handling, use the HTTP error code 429 to detect throttling. The failed response includes the Retry-After response header. Backing off requests using the Retry-After delay is the fastest way to recover from throttling because GraphShield continues to log resource usage while a client is being throttled. Wait the number of seconds specified in the Retry-After header. Retry the request. If the request fails again with a 429 error code, you are still being throttled. Continue to use the recommended Retry-After delay and retry the request until it succeeds. Tip If no Retry-After header is provided in the response, we recommend implementing an exponential backoff retry policy. In addition to the Retry-After header, GraphShield includes X-RateLimit-Limit and X-RateLimit-Remaining infos in body of the throttled response: { \"message\" : \"Too many requests, please try again later...\" , \"body\" : { \"rateLimitExceeded\" : { \"rateLimitWindow\" : 900000 , // In ms \"ratelimitMax\" : 90000 // In # of requests } } } How GraphShield makes it transparent? GraphShield generates its throttling responses using the same schema and headers as the Microsoft Graph, making throttling management transparent for your app. See Microsoft Graph throttling guidance for reference.","title":"Throttling Guidance"},{"location":"integration/throttling/#throttling-guidance","text":"Throttling limits the number of concurrent calls to a service to prevent overuse of resources. Graphshield is designed to handle a high volume of requests. If an overwhelming number of requests occurs, throttling helps maintain optimal performance and reliability of the service.","title":"Throttling Guidance"},{"location":"integration/throttling/#common-throttling-scenarios","text":"The most common causes of throttling of clients include: - A large number of requests across all applications in a our environments. - A large number of requests from a particular application across all environments.","title":"Common Throttling Scenarios"},{"location":"integration/throttling/#what-happens-when-throttling-occurs","text":"When a throttling threshold is exceeded, GraphShield limits any further requests from that client for a period of time. When throttling occurs, GraphShield returns HTTP status code 429 (Too many requests), and the requests fail. A suggested wait time is returned in the response header of the failed request. GraphShield is conforming to the IETF ratelimit standardization proposal .","title":"What Happens when Throttling Occurs?"},{"location":"integration/throttling/#best-practices-to-avoid-throttling","text":"Programming patterns like continuously polling a resource to check for updates and regularly scanning resource collections to check for new or deleted resources are more likely to lead to applications being throttled and degrade overall performances. Before any throttling, GraphShield provides two useful headers included in every responses so that you can monitor your own activity level: - X-RateLimit-Limit : The limit of requests in a perdiod of time (aka \"window\") - X-RateLimit-Remaining : The current number of requests that could be made during the current window.","title":"Best Practices to Avoid Throttling"},{"location":"integration/throttling/#how-to-handle-throttling","text":"The following are best practices for handling throttling: - Reduce the number of operations per request. - Reduce the frequency of calls. - Avoid immediate retries, because all requests accrue against your usage limits. When you implement error handling, use the HTTP error code 429 to detect throttling. The failed response includes the Retry-After response header. Backing off requests using the Retry-After delay is the fastest way to recover from throttling because GraphShield continues to log resource usage while a client is being throttled. Wait the number of seconds specified in the Retry-After header. Retry the request. If the request fails again with a 429 error code, you are still being throttled. Continue to use the recommended Retry-After delay and retry the request until it succeeds. Tip If no Retry-After header is provided in the response, we recommend implementing an exponential backoff retry policy. In addition to the Retry-After header, GraphShield includes X-RateLimit-Limit and X-RateLimit-Remaining infos in body of the throttled response: { \"message\" : \"Too many requests, please try again later...\" , \"body\" : { \"rateLimitExceeded\" : { \"rateLimitWindow\" : 900000 , // In ms \"ratelimitMax\" : 90000 // In # of requests } } }","title":"How to Handle Throttling"},{"location":"integration/throttling/#how-graphshield-makes-it-transparent","text":"GraphShield generates its throttling responses using the same schema and headers as the Microsoft Graph, making throttling management transparent for your app. See Microsoft Graph throttling guidance for reference.","title":"How GraphShield makes it transparent?"},{"location":"proxy-policies/","text":"Use Policies to Protect your Microsoft 365 Environment GraphShield helps you to protect you Microsoft 365 environment though easy-to-configure but powerful policies. Policies and Rules At its core, GraphShield provides a set of policies, each policy beeing comprised of one or more rules. In that sense, policies could be seen as a category of rules, useful to navigate rules in a logical manner. For instance: graph LR subgraph Policies classification[Classification] conditionalaccess[Conditional Access] end subgraph Rules hideclassifiedgroups[Hide Classified Groups] threatintelligence[Threat Intelligence] ipbasedcontrol[IP-based Control] locationbasedcontrol[Location-based Control] end classification --> hideclassifiedgroups conditionalaccess --> threatintelligence conditionalaccess --> ipbasedcontrol conditionalaccess --> locationbasedcontrol Rules Configurations Rules could be enabled or disabled individually, and have a specific configuration for each app. For instance: graph LR subgraph Apps app1[App 1] app2[App 2] end subgraph Configurations threatintelligenceAppA[Threat Intelligence] threatintelligenceApp2[Threat Intelligence] locationbasedcontrolApp2[Location-based Control] hideclassifiedgroupsApp2[Hide Classified Groups] end app1 --> threatintelligenceAppA app2 --> threatintelligenceApp2 app2 --> locationbasedcontrolApp2 app2 --> hideclassifiedgroupsApp2","title":"Use Policies to Protect your Microsoft 365 Environment"},{"location":"proxy-policies/#use-policies-to-protect-your-microsoft-365-environment","text":"GraphShield helps you to protect you Microsoft 365 environment though easy-to-configure but powerful policies.","title":"Use Policies to Protect your Microsoft 365 Environment"},{"location":"proxy-policies/#policies-and-rules","text":"At its core, GraphShield provides a set of policies, each policy beeing comprised of one or more rules. In that sense, policies could be seen as a category of rules, useful to navigate rules in a logical manner. For instance: graph LR subgraph Policies classification[Classification] conditionalaccess[Conditional Access] end subgraph Rules hideclassifiedgroups[Hide Classified Groups] threatintelligence[Threat Intelligence] ipbasedcontrol[IP-based Control] locationbasedcontrol[Location-based Control] end classification --> hideclassifiedgroups conditionalaccess --> threatintelligence conditionalaccess --> ipbasedcontrol conditionalaccess --> locationbasedcontrol","title":"Policies and Rules"},{"location":"proxy-policies/#rules-configurations","text":"Rules could be enabled or disabled individually, and have a specific configuration for each app. For instance: graph LR subgraph Apps app1[App 1] app2[App 2] end subgraph Configurations threatintelligenceAppA[Threat Intelligence] threatintelligenceApp2[Threat Intelligence] locationbasedcontrolApp2[Location-based Control] hideclassifiedgroupsApp2[Hide Classified Groups] end app1 --> threatintelligenceAppA app2 --> threatintelligenceApp2 app2 --> locationbasedcontrolApp2 app2 --> hideclassifiedgroupsApp2","title":"Rules Configurations"},{"location":"proxy-policies/anonymization/","text":"Anonymization Policy GraphShield policy that anonymize Microsoft Graph requests. Anonymize Response Anonymize the Microsoft Graph responses. Anonymize Response rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Action The anonymization action that should be applied to the response. Supported values are redact and randomize Tip Anonymize Response rule is disabled by default.","title":"Anonymization Policy"},{"location":"proxy-policies/anonymization/#anonymization-policy","text":"GraphShield policy that anonymize Microsoft Graph requests.","title":"Anonymization Policy"},{"location":"proxy-policies/anonymization/#anonymize-response","text":"Anonymize the Microsoft Graph responses. Anonymize Response rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Action The anonymization action that should be applied to the response. Supported values are redact and randomize Tip Anonymize Response rule is disabled by default.","title":"Anonymize Response"},{"location":"proxy-policies/auditing/","text":"Auditing Policy GraphShield policy that manages requests auditing. Audit GraphShield rule that creates an audit trail record for the request. Audit rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Tip Audit rule is enabled by default.","title":"Auditing Policy"},{"location":"proxy-policies/auditing/#auditing-policy","text":"GraphShield policy that manages requests auditing.","title":"Auditing Policy"},{"location":"proxy-policies/auditing/#audit","text":"GraphShield rule that creates an audit trail record for the request. Audit rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Tip Audit rule is enabled by default.","title":"Audit"},{"location":"proxy-policies/beta-endpoints/","text":"Beta Endpoints Policy GraphShield policy that controls access to Microsoft Graph /beta endpoints. Disable Beta Endpoints GraphShield rule that denies access to the Microsoft Graph /beta endpoints. Disable Beta Endpoints rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Deny Beta Denies access to the Microsoft Graph beta endpoints. Returns an HTTP 403 Forbidden status code in case of violation. Tip Disable Beta Endpoints rule is disabled by default.","title":"Beta Endpoints Policy"},{"location":"proxy-policies/beta-endpoints/#beta-endpoints-policy","text":"GraphShield policy that controls access to Microsoft Graph /beta endpoints.","title":"Beta Endpoints Policy"},{"location":"proxy-policies/beta-endpoints/#disable-beta-endpoints","text":"GraphShield rule that denies access to the Microsoft Graph /beta endpoints. Disable Beta Endpoints rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Deny Beta Denies access to the Microsoft Graph beta endpoints. Returns an HTTP 403 Forbidden status code in case of violation. Tip Disable Beta Endpoints rule is disabled by default.","title":"Disable Beta Endpoints"},{"location":"proxy-policies/classification/","text":"Classification Policy GraphShield policy that controls access to classified contents. Hide Classified Groups GraphShield rule that hides classified groups (including Microsoft Teams teams and SharePoint sites) based on their sensitivity labels. Hide Classified Groups rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Hidden Labels A list of comma-separated labels whose related groups will be hidden from Microsoft Graph responses. If the response contains multiple groups (from a query that requests a collection of resources), the hidden groups are simply removed from the results and the results count is updated accordingly. If the response returns a single group (from a query that requests a specific resource from a collection of resources), GraphShield returns an HTTP 404 Not Found status code Tip Hide Classified Groups rule is disabled by default.","title":"Classification Policy"},{"location":"proxy-policies/classification/#classification-policy","text":"GraphShield policy that controls access to classified contents.","title":"Classification Policy"},{"location":"proxy-policies/classification/#hide-classified-groups","text":"GraphShield rule that hides classified groups (including Microsoft Teams teams and SharePoint sites) based on their sensitivity labels. Hide Classified Groups rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Hidden Labels A list of comma-separated labels whose related groups will be hidden from Microsoft Graph responses. If the response contains multiple groups (from a query that requests a collection of resources), the hidden groups are simply removed from the results and the results count is updated accordingly. If the response returns a single group (from a query that requests a specific resource from a collection of resources), GraphShield returns an HTTP 404 Not Found status code Tip Hide Classified Groups rule is disabled by default.","title":"Hide Classified Groups"},{"location":"proxy-policies/conditional-access/","text":"Conditional Access Policy GraphShield policy that controls access to the Microsoft Graph based on conditional access rules. Threat Intelligence GraphShield threat intelligence database includes over 620M malicious IP addresses. Among others, we track Tor nodes and open proxies. Data is checked and updated continuously. Updates occur as changes are detected to reduce false positives to their minimum. Threat Intelligence rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Deny Bogon Deny IP Addresses known as Bogon : an unassigned, unaddressable IP address. Returns an HTTP 403 Forbidden status code in case of violation. Deny Tor Deny IP addresses known as Tor relays (exit relay node, middle relay node or a bridge). Returns an HTTP 403 Forbidden status code in case of violation. Deny Proxy Deny IP addresses known as a proxy. It includes HTTP/HTTPS/SSL/SOCKS/CONNECT and transparent proxies. Returns an HTTP 403 Forbidden status code in case of violation. Deny Abuser Deny IP addresses that are a known source of abuse (e.g. spam, harvesters, registration bots). Returns an HTTP 403 Forbidden status code in case of violation. Deny Attacker Deny IP addresses that are a known source of malicious activity (e.g. attacks, malware, botnet activity). Returns an HTTP 403 Forbidden status code in case of violation. Tip All GraphShield Threat Intelligence options are enabled by default. IP-based Control Controls access to the target API based on IP-based conditional access rules. IP-based Control rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Allowed IPs Authorized IP Addresses as a list of comma-separated IPs or IP ranges. It handles IPv6, IPv4, and IPv4-mapped over IPv6 addresses. Returns an HTTP 403 Forbidden status code in case of violation. Tip IP-based Control rule is disabled by default. Location-based Control Controls access to the target API based on location conditional access rules. Location-based Control rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Allowed Countries Authorized countries as a list of comma-separated country codes (The 2 letter ISO 3166-1 alpha-2 code associated with this IP.) Returns an HTTP 403 Forbidden status code in case of violation. Tip Location-based Control rule is disabled by default.","title":"Conditional Access Policy"},{"location":"proxy-policies/conditional-access/#conditional-access-policy","text":"GraphShield policy that controls access to the Microsoft Graph based on conditional access rules.","title":"Conditional Access Policy"},{"location":"proxy-policies/conditional-access/#threat-intelligence","text":"GraphShield threat intelligence database includes over 620M malicious IP addresses. Among others, we track Tor nodes and open proxies. Data is checked and updated continuously. Updates occur as changes are detected to reduce false positives to their minimum. Threat Intelligence rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Deny Bogon Deny IP Addresses known as Bogon : an unassigned, unaddressable IP address. Returns an HTTP 403 Forbidden status code in case of violation. Deny Tor Deny IP addresses known as Tor relays (exit relay node, middle relay node or a bridge). Returns an HTTP 403 Forbidden status code in case of violation. Deny Proxy Deny IP addresses known as a proxy. It includes HTTP/HTTPS/SSL/SOCKS/CONNECT and transparent proxies. Returns an HTTP 403 Forbidden status code in case of violation. Deny Abuser Deny IP addresses that are a known source of abuse (e.g. spam, harvesters, registration bots). Returns an HTTP 403 Forbidden status code in case of violation. Deny Attacker Deny IP addresses that are a known source of malicious activity (e.g. attacks, malware, botnet activity). Returns an HTTP 403 Forbidden status code in case of violation. Tip All GraphShield Threat Intelligence options are enabled by default.","title":"Threat Intelligence"},{"location":"proxy-policies/conditional-access/#ip-based-control","text":"Controls access to the target API based on IP-based conditional access rules. IP-based Control rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Allowed IPs Authorized IP Addresses as a list of comma-separated IPs or IP ranges. It handles IPv6, IPv4, and IPv4-mapped over IPv6 addresses. Returns an HTTP 403 Forbidden status code in case of violation. Tip IP-based Control rule is disabled by default.","title":"IP-based Control"},{"location":"proxy-policies/conditional-access/#location-based-control","text":"Controls access to the target API based on location conditional access rules. Location-based Control rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Allowed Countries Authorized countries as a list of comma-separated country codes (The 2 letter ISO 3166-1 alpha-2 code associated with this IP.) Returns an HTTP 403 Forbidden status code in case of violation. Tip Location-based Control rule is disabled by default.","title":"Location-based Control"},{"location":"proxy-policies/vip-protection/","text":"VIP Protection Policy GraphShield policy that controls access to VIP-related resources. Hide VIPs GraphShield rule that hides VIPs user profiles. Hide VIPs rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Hidden Labels A list of comma-separated users whose related profiles will be hidden from Microsoft Graph responses. If the response contains multiple users (from a query that requests a collection of resources), the hidden users are simply removed from the results and the results count is updated accordingly. If the response returns a single user (from a query that requests a specific resource from a collection of resources), GraphShield returns an HTTP 404 Not Found status code Tip Hide VIPs rule is disabled by default.","title":"VIP Protection Policy"},{"location":"proxy-policies/vip-protection/#vip-protection-policy","text":"GraphShield policy that controls access to VIP-related resources.","title":"VIP Protection Policy"},{"location":"proxy-policies/vip-protection/#hide-vips","text":"GraphShield rule that hides VIPs user profiles. Hide VIPs rule supports the following options: Option Description Enabled Defines if the rule is enabled or disabled. Hidden Labels A list of comma-separated users whose related profiles will be hidden from Microsoft Graph responses. If the response contains multiple users (from a query that requests a collection of resources), the hidden users are simply removed from the results and the results count is updated accordingly. If the response returns a single user (from a query that requests a specific resource from a collection of resources), GraphShield returns an HTTP 404 Not Found status code Tip Hide VIPs rule is disabled by default.","title":"Hide VIPs"},{"location":"trust-center/security-policy/","text":"Security Policy As a provider of products and services for many organizations, we recognize how important it is to help protect user privacy and security. We understand that secure products are instrumental in maintaining the trust users place in us and we strive to create innovative products that both serve user needs and operate in the user\u2019s best interest. How GraphShield handles security vulnerabilities? Supported Versions The following versions of GraphShield are currently being supported with security updates. Version Supported 1.x.x \u2705 0.x.x \ud83d\udeab Reporting a Vulnerability If you believe you have discovered a vulnerability or have a security incident to report, please send us a message to security@graphshield.io (english as a preferred languages) that includes a detailed reports with reproducible steps. GraphShield\u2019s vulnerability disclosure policy We believe that vulnerability disclosure is a two-way street. Vendors, as well as researchers, must act responsibly. This is why GraphShield adheres to a 90-day disclosure deadline. We notify vendors of vulnerabilities immediately, with details shared in public with the defensive community after 90 days, or sooner if the vendor releases a fix. That deadline can vary in the following ways: - If a deadline is due to expire on a weekend or US public holiday, the deadline will be moved to the next normal work day. - Before the 90-day deadline has expired, if a vendor lets us know that a patch is scheduled for release on a specific day that will fall within 14 days following the deadline, we will delay the public disclosure until the availability of the patch. - When we observe a previously unknown and unpatched vulnerability in software under active exploitation (a \u201c0day\u201d), we believe that more urgent action\u2014within 7 days\u2014is appropriate. The reason for this special designation is that each day an actively exploited vulnerability remains undisclosed to the public and unpatched, more devices or accounts will be compromised. Seven days is an aggressive timeline and may be too short for some vendors to update their products, but it should be enough time to publish advice about possible mitigations, such as temporarily disabling a service, restricting access, or contacting the vendor for more information. As a result, after 7 days have elapsed without a patch or advisory, we will support researchers making details available so that users can take steps to protect themselves. As always, we reserve the right to bring deadlines forwards or backwards based on extreme circumstances. We remain committed to treating all vendors strictly equally. GraphShield expects to be held to the same standard. This policy is strongly in line with our desire to improve industry response times to security bugs, but also results in softer landings for bugs marginally over deadline. Creating pressure towards more reasonably-timed fixes will result in smaller windows of opportunity for blackhats to abuse vulnerabilities. In our opinion, vulnerability disclosure policies such as ours result in greater overall safety for users of the Internet.","title":"Security Policy"},{"location":"trust-center/security-policy/#security-policy","text":"As a provider of products and services for many organizations, we recognize how important it is to help protect user privacy and security. We understand that secure products are instrumental in maintaining the trust users place in us and we strive to create innovative products that both serve user needs and operate in the user\u2019s best interest.","title":"Security Policy"},{"location":"trust-center/security-policy/#how-graphshield-handles-security-vulnerabilities","text":"","title":"How GraphShield handles security vulnerabilities?"},{"location":"trust-center/security-policy/#supported-versions","text":"The following versions of GraphShield are currently being supported with security updates. Version Supported 1.x.x \u2705 0.x.x \ud83d\udeab","title":"Supported Versions"},{"location":"trust-center/security-policy/#reporting-a-vulnerability","text":"If you believe you have discovered a vulnerability or have a security incident to report, please send us a message to security@graphshield.io (english as a preferred languages) that includes a detailed reports with reproducible steps.","title":"Reporting a Vulnerability"},{"location":"trust-center/security-policy/#graphshields-vulnerability-disclosure-policy","text":"We believe that vulnerability disclosure is a two-way street. Vendors, as well as researchers, must act responsibly. This is why GraphShield adheres to a 90-day disclosure deadline. We notify vendors of vulnerabilities immediately, with details shared in public with the defensive community after 90 days, or sooner if the vendor releases a fix. That deadline can vary in the following ways: - If a deadline is due to expire on a weekend or US public holiday, the deadline will be moved to the next normal work day. - Before the 90-day deadline has expired, if a vendor lets us know that a patch is scheduled for release on a specific day that will fall within 14 days following the deadline, we will delay the public disclosure until the availability of the patch. - When we observe a previously unknown and unpatched vulnerability in software under active exploitation (a \u201c0day\u201d), we believe that more urgent action\u2014within 7 days\u2014is appropriate. The reason for this special designation is that each day an actively exploited vulnerability remains undisclosed to the public and unpatched, more devices or accounts will be compromised. Seven days is an aggressive timeline and may be too short for some vendors to update their products, but it should be enough time to publish advice about possible mitigations, such as temporarily disabling a service, restricting access, or contacting the vendor for more information. As a result, after 7 days have elapsed without a patch or advisory, we will support researchers making details available so that users can take steps to protect themselves. As always, we reserve the right to bring deadlines forwards or backwards based on extreme circumstances. We remain committed to treating all vendors strictly equally. GraphShield expects to be held to the same standard. This policy is strongly in line with our desire to improve industry response times to security bugs, but also results in softer landings for bugs marginally over deadline. Creating pressure towards more reasonably-timed fixes will result in smaller windows of opportunity for blackhats to abuse vulnerabilities. In our opinion, vulnerability disclosure policies such as ours result in greater overall safety for users of the Internet.","title":"GraphShield\u2019s vulnerability disclosure policy"}]}